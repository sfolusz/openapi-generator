{{>partial_header}}
package {{packageName}}

import (
	"errors"
    "fmt"
    "github.com/gofiber/fiber/v2"
	"io/ioutil"
	"mime/multipart"
	"os"
	"strconv"
	"strings"
)

// A Route defines the parameters for an api endpoint
type Route struct {
	Name		string
	Method	    string
	Pattern	    string
	HandlerFunc fiber.Handler
}

// Routes are a collection of defined api endpoints
type Routes []Route

// Router defines the required methods for retrieving api routes
type Router interface {
	Routes() Routes
}

const errMsgRequiredMissing = "required parameter is missing"

type Config = fiber.Config

// NewRouter instantiates handlers based on controllers and creates a new router for any number of api routers
func NewRouter(config Config, controllers []interface{}) (*fiber.App, error) {
    routers, err := instantiateHandlers(controllers)
    if err != nil {
        return nil, errors.New("could not instantiate handlers: " + err.Error())
    }

	router := fiber.New(config)
	for _, api := range routers {
		for _, route := range api.Routes() {
            router.Add(route.Method, ReplaceOpenApiPathParamsStyleWithFiberPathParamsStyle(route.Pattern), route.HandlerFunc)
		}
	}

	return router, nil
}

func instantiateHandlers(controllers []interface{}) ([]Router, error) {
    routers := make([]Router, 0)

    for _, c := range controllers {
        switch cType := c.(type) {
{{#apiInfo}}{{#apis}}
        case {{classname}}Controller:
            routers = append(routers, New{{classname}}Handler(c.({{classname}}Controller)))
{{/apis}}{{/apiInfo}}
        default:
            return nil, errors.New(fmt.Sprintf("such controller type %T does not exist in api", cType))
        }
    }

    return routers, nil
}

// ReadFormFileToTempFile reads file data from a request form and writes it to a temporary file
func ReadFormFileToTempFile(f *fiber.Ctx, key string) (*os.File, error) {
    fileHeader, err := f.FormFile(key)
	if err != nil {
		return nil, err
	}

	return readFileHeaderToTempFile(fileHeader)
}

// ReadFormFilesToTempFiles reads files array data from a request form and writes it to a temporary files
func ReadFormFilesToTempFiles(f *fiber.Ctx, key string) ([]*os.File, error) {
    multipartForm, err := f.MultipartForm()
    if err != nil {
		return nil, err
	}

	files := make([]*os.File, 0, len(multipartForm.File[key]))

	for _, fileHeader := range multipartForm.File[key] {
		file, err := readFileHeaderToTempFile(fileHeader)
		if err != nil {
			return nil, err
		}

		files = append(files, file)
	}

	return files, nil
}

// readFileHeaderToTempFile reads multipart.FileHeader and writes it to a temporary file
func readFileHeaderToTempFile(fileHeader *multipart.FileHeader) (*os.File, error) {
	formFile, err := fileHeader.Open()
	if err != nil {
		return nil, err
	}

	defer formFile.Close()

	fileBytes, err := ioutil.ReadAll(formFile)
	if err != nil {
		return nil, err
	}

	file, err := ioutil.TempFile("", fileHeader.Filename)
	if err != nil {
		return nil, err
	}

	defer file.Close()

	file.Write(fileBytes)

	return file, nil
}

// parseInt64Parameter parses a string parameter to an int64.
func parseInt64Parameter(param string, required bool) (int64, error) {
	if param == "" {
		if required {
			return 0, errors.New(errMsgRequiredMissing)
		}

		return 0, nil
	}

	return strconv.ParseInt(param, 10, 64)
}

// parseInt32Parameter parses a string parameter to an int32.
func parseInt32Parameter(param string, required bool) (int32, error) {
	if param == "" {
		if required {
			return 0, errors.New(errMsgRequiredMissing)
		}

		return 0, nil
	}

	val, err := strconv.ParseInt(param, 10, 32)
	if err != nil {
		return -1, err
	}

	return int32(val), nil
}

// parseBoolParameter parses a string parameter to a bool
func parseBoolParameter(param string) (bool, error) {
	val, err := strconv.ParseBool(param)
	if err != nil {
		return false, err
	}

	return bool(val), nil
}

// parseInt64ArrayParameter parses a string parameter containing array of values to []int64.
func parseInt64ArrayParameter(param, delim string, required bool) ([]int64, error) {
	if param == "" {
		if required {
			return nil, errors.New(errMsgRequiredMissing)
		}

		return nil, nil
	}

	str := strings.Split(param, delim)
	ints := make([]int64, len(str))

	for i, s := range str {
		if v, err := strconv.ParseInt(s, 10, 64); err != nil {
			return nil, err
		} else {
			ints[i] = v
		}
	}

	return ints, nil
}

// parseInt32ArrayParameter parses a string parameter containing array of values to []int32.
func parseInt32ArrayParameter(param, delim string, required bool) ([]int32, error) {
	if param == "" {
		if required {
			return nil, errors.New(errMsgRequiredMissing)
		}

		return nil, nil
	}

	str := strings.Split(param, delim)
	ints := make([]int32, len(str))

	for i, s := range str {
		if v, err := strconv.ParseInt(s, 10, 32); err != nil {
			return nil, err
		} else {
			ints[i] = int32(v)
		}
	}

	return ints, nil
}
